#include "Map.h"
#include <rapidxml/rapidxml.hpp>
#include <fstream>
#include <sstream>
#include <iostream>
#include <vector>
#include <string>
#include "RenderScheduler.h"
#include "SDL2/SDL.h"
#include "SDL2/SDL_image.h"
#include <map>

using namespace rapidxml;

int sibling_count(xml_node<>* pNode) {
	int counter = 0;
	while (pNode) {
		++counter;
		pNode = pNode->next_sibling();
	}
	return counter;
}

int stosi(const std::string& str) {//string to signed integer
	int i = 0;
	char sign = 1;
	for (const auto c : str) {
		if (c == '-' && !i)
			sign = sign * -1;
		else if ((c < '0' || c > '9'))
			break;
		else
			i = i*10+c-'0';
	}
	return i*sign;
}

Map::Map(const std::string& MapFile, RenderScheduler* const RS) : RS(RS) {
	Reload(MapFile);
}

void Map::Reload(const std::string& MapFile) {
	//Dealocate (Reduce mem usage peak)
	Levels = std::vector<Level>();

	//Loading MapFile
	xml_document<> doc;
	std::ifstream file(MapFile);
	std::stringstream buffer;
	buffer << file.rdbuf();
	file.close();
	std::string content(buffer.str());
	doc.parse<0>(&content[0]);
	xml_node<>* pRoot = doc.first_node();
	xml_node<>* pNode;

	std::string TexPath = (pRoot->first_node("tileset")->first_node("image")->first_attribute("source"))->value();
	SDL_Texture* texture = RS->GetTexture(TexPath);

	//Updating variables
	minLevel = 0;
	pNode = pRoot->first_node("layer");
	std::vector<xml_node<>*> InfoLayers;
	std::vector<xml_node<>*> SpriteLayers;
	while (pNode) {
		//separating Info and Sprite layers
		xml_attribute<> *pAttr = pNode->first_attribute("name");
		std::string str = pAttr->value();
		if (str.find("Behaviour") != std::string::npos)
			InfoLayers.push_back(pNode);
		else { //str shall contain only integers
			SpriteLayers.push_back(pNode);
			int LName = stosi(str);
			if (LName < minLevel)
				minLevel = LName;
		}
		pNode = pNode->next_sibling();
	}

	//Updating Levels vector
	std::vector<Level> tmp(SpriteLayers.size());
	Levels = std::move(tmp);

	for (int i = 0; i < SpriteLayers.size(); ++i) {
		pNode = SpriteLayers[i];
		int width = std::stoi((pNode->first_attribute("width"))->value());
		int height = std::stoi((pNode->first_attribute("height"))->value());
		int size = width*height;
		pNode = pNode->first_node("data")->first_node("tile");

		std::vector<std::tuple<SDL_Texture*, int8_t, int8_t>> Tiles(size, std::make_tuple(nullptr, 0, 0));
		for(int j = 0; j < size; ++j) {
			if (pNode->first_attribute("gid")) {
				int id = std::stoi(pNode->first_attribute()->value()) - 1;
				if (id < 0)
					id = 0;
				std::get<0>(Tiles[j]) = texture;
				std::get<1>(Tiles[j]) = id%width;
				std::get<2>(Tiles[j]) = (id/width);
			}
			pNode = pNode->next_sibling();
		}
		int index = stosi(SpriteLayers[i]->first_attribute("name")->value()) - minLevel;
		Levels[index].Tiles = std::move(Tiles);
		Levels[index].Size = std::make_pair(width, height);
	}
}


Level* Map::getLevel(const int Level) {
	return &Levels[Level-minLevel]; //vectors do not accept negative index
}


void Map::Update(const Camera& cam) {

	auto Height = (cam.Get()).VisionHeight;
	auto Width = (cam.Get()).VisionWidth;
	auto x = std::get<0>((cam.Get()).P);
	auto y = std::get<1>((cam.Get()).P);
	auto z = std::get<2>((cam.Get()).P);

	auto tile = Levels[1].Tiles[0];
	auto x0 = std::get<1>(tile)*32;
	auto y0 = std::get<2>(tile)*32;
	auto texture = std::get<0>(tile);
	//if (texture == nullptr) std::cout << "ERR" << std::endl;
	SDL_Rect srcrect = {x0, y0, x0+32, 32};
	std::cout << int(x0) << " " << int(y0) << std::endl;
	SDL_Rect dstrect = { 0, 0, 100, 100 };
	RS->ScheduleDraw(1, texture, srcrect, dstrect);


	/*
	for (int i = 0; i < 5; ++i) {
		SDL_Rect srcrect = { 0, 0, 32*i, 32 };
		SDL_Rect dstrect = { 0, 0, 32*i, 32 };
		RS->ScheduleDraw(0, MapSpriteSheet, srcrect, dstrect);
	}
	*/
}
